# Универсальные операции с итераторами

## Проблематика работы с разными категориями итераторов

Наличие итераторов различных категорий усложняет написание обобщенного кода, так как операции, поддерживаемые одним типом, могут не поддерживаться другим. В частности:

- **Random Access итераторы** могут быть продвинуты на несколько шагов вперед за O(1) с помощью `+=`
- **Bidirectional итераторы** требуют циклического вызова `++` для продвижения

## Стандартные решения

В стандартной библиотеке имеются функции для универсальной работы с итераторами:

### `std::advance`
Принимает итератор и количество шагов для продвижения:
- Для Random Access использует `+=` (O(1))
- Для других категорий использует цикл с `++` или `--` (O(n))

### `std::next`
Аналогична `std::advance`, но:
- Может вызываться без второго аргумента (продвигает на 1 шаг)
- Не изменяет исходный итератор, а возвращает новый

### `std::prev`
Аналогична `std::next`, но двигает итераторы в обратном направлении (использует `--`)

### `std::distance`
Вычисляет расстояние между итераторами:
- Для Random Access работает за O(1) (использует вычитание)
- Для других категорий - O(n) (линейный проход)

## Пример использования

```cpp
std::vector<int> v{1, 2, 3, 4, 5};  // Random Access
std::list<int> l{1, 2, 3, 4, 5};    // Bidirectional

auto v_it = v.begin();
auto l_it = l.begin();

std::advance(v_it, 3);  // Эквивалентно v_it += 3
std::advance(l_it, 3);  // Эквивалентно for (int i = 0; i < 3; ++i) ++l_it;

auto vv_it = std::next(v_it, 2);
auto ll_it = std::next(l_it, 2);

std::cout << std::distance(v_it, vv_it);  // 2 (O(1))
std::cout << std::distance(l_it, ll_it);  // 2 (O(n))
```

## Задание: реализация аналогов

Требуется реализовать шаблонные функции с аналогичной функциональностью:

1. **Advance** - аналог `std::advance`
2. **Next** - аналог `std::next`
3. **Prev** - аналог `std::prev`
4. **Distance** - аналог `std::distance`

### Детали реализации

Категория итератора определяется через `std::iterator_traits`:

```cpp
using IteratorType = typename std::vector<T>::iterator;
std::iterator_traits<IteratorType>::iterator_category category;
```

### Важные замечания

1. Наивная реализация с `if` не подойдет:
   - Типы нельзя сравнивать через `==`
   - Обе ветки `if` будут компилироваться, что вызовет ошибки

2. Рекомендуемые механизмы:
   - `constexpr if` для условной компиляции
   - `std::is_same`/`std::is_same_v` для сравнения типов
   - `std::is_base_of`/`std::is_base_of_v` для проверки наследования

## Технические требования

Реализация должна:
1. Корректно работать со всеми категориями итераторов
2. Использовать наиболее эффективные операции для каждой категории
3. Быть реализована средствами C++17