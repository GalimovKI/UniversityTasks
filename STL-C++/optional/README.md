# Optional


Это задание познакомит вас с основами ручного управления временем жизни объектов на примере класса Optional.

При создании объектов на стеке компилятор самостоятельно выделяет память достаточную для хранения объекта и инициализирует объект, вызывая соответствующий конструктор, а при выходе из блока самостоятельно очищает память и завершает время жизни объекта посредством вызова деструктора.

Если речь идет про динамическую область памяти, то этот процесс частично контролируется пользователем — операция new заставляет выделить память под объект в куче и создать его там же, операция delete инициирует вызов деструктора и освобождает выделенную память.

А что, если хочется самостоятельно определять в какой момент объект должен быть создан и уничтожен, то есть не привязывать время жизни объекта к памяти, которая его содержит? Это может быть полезно, например, для эффективной работы std::vector<T> — если объекты типа T требуют много ресурсов на создание, то может быть накладно иметь capacity объектов, когда реально используется только size из них. Для решения этой проблемы std::vector хранит лишь "сырую" память достаточную для хранения capacity объектов, а сами объекты создаются и удаляются вручную по мере необходимости.

Placement new и явный вызов деструктора
Для ручного создания объекта по конкретному месту в памяти (заранее выделенного на стеке или в куче) можно воспользоваться специальной формой операции new — placement new.

Пусть ptr — указатель на область памяти достаточного размера для хранения объекта типа T. Чтобы создать объект в данном месте можно воспользоваться следующим синтаксисом:

new(ptr) T(args...);  // args... - аргументы конструктора
Заметьте, что отличие состоит в явном указании адреса в скобках и отсутствии выделения дополнительной памяти.

Приведем пример неправильного использования placement new:
``` c++
A a;                 // создаем объект типа A
new(&a) A(args...);  // пересоздаем объект, деструктор старого объекта при этом не вызывается!
```
Для корректной работы предыдущего примера необходимо удалить старый объект перед созданием нового:
```c++
A a;                 // создаем объект типа A
a.~A();              // явно вызываем деструктор старого объекта
new(&a) A(args...);  // создаем новый объект
```
Код вида ```c++ a = A(args...);``` логически эквивалентен приведенному выше, но отличается с точки зрения времени жизни объектов. Кроме того, код выше работает и в случае, когда для класса A не определена операция присваивания.

Важно отметить, что после последнего создания явно вызывать деструктор не нужно, так как компилятор вызывает его самостоятельно при выходе из блока:
```c++
A a;                 // создаем объект типа A
a.~A();              // явно вызываем деструктор старого объекта
new(&a) A(args...);  // создаем новый объект
a.~A();              // UB: деструктор вновь вызовется при выходе из блока
Для создания объекта "с нуля" в сырой памяти нужно сначала предоставить эту память, а затем приступить к созданию:
```
```c++
char memory[sizeof(A)];  // создаем сырую память размера sizeof(A) байт
A* obj = new(memory) A("param");  // создаем объект A, возвращается тот же указатель, но типа A*
// ... use of A
obj->~A();  // важно самостоятельно вызвать деструктор! memory будет освобожден как массив char, а не как объект A
```
Аналогичный пример в динамической памяти:

```c++
char* memory = new char[sizeof(A)];  // или operator new(sizeof(A));
A* obj = new(memory) A("param");
// ... use of A
obj->~A();
delete[] memory;  // так как выделяли массив char, то и удалять нужно массив char
                  // или operator delete(memory);
```
Дополнение: вместо char на практике стоит использовать std::byte. Кроме того, С++ при выделении памяти следует правилу "выравнивания", согласно которому объекты могут располагаться только по определенным адресам (как правило, адрес должен быть кратен размеру объекта). Более подробно здесь. Чтобы гарантировать корректное расположение памяти, можно воспользоваться спецификатором alignas. Таким образом, наиболее правильным способом выделить память на стеке будет:
```c++
alignas(A) std::byte memory[sizeof(A)];  // создаем сырую память размера sizeof(A) байт, а в динамической памяти:
```
```c++
void* memory = operator new(sizeof(A), std::align_val_t(alignof(A)));
// при этом нужно будет использовать `operator delete(memory, std::align_val_t(alignof(A)))` для освобождения std::optional (C++17)
```

Шаблон std::optional предоставляет безопасный интерфейс для управления временем жизни объектов. Он принимает ровно 1 шаблонный параметр (тип хранимого объекта) и может находиться в одном из двух состояний — объект жив или объект мертв.

В любой момент времени можно узнать состояние объекта (has_value), или изменить его (emplace, reset). При этом класс самостоятельно принимает решение о том в какой момент вызывать деструктор/конструктор объекта, освобождая пользователя от этих забот.

## Детали реализации

Реализуйте шаблон Optional<T>, упрощенный аналог std::optional<T>. В полях шаблона сохраните память (массив char или std::byte) достаточного размера (память должна располагаться на стеке!), а также булевское поле, в котором будет храниться информация о том жив ли объект. Шаблонный класс должен поддерживать следующие методы:

- Конструктор по умолчанию. Создает Optional с "мертвым" объектом.
- Конструктор копирования. Создает копию, если копируемый объект жив, и пустой Optional иначе.
- Конструктор перемещения. Если перемещаемый Optional пуст, то создается пустой объект. Иначе перемещаем объект из другого Optional. При этом старый Optional по прежнему остается живым!
- Неявный конструктор от const T& и T&&. Создает Optional созданный с помощью переданного объекта (копированием или перемещением)
- Деструктор. Вызывает деструктор объекта, если тот жив, и ничего не делает, если мертв.
- Копирующее и перемещающее присваивание. Если копируемый(перемещаемый) объект мертв, то и свой объект становится мертвым. Иначе своему объекту нужно соответствующим образом присвоить другой (и если был мертв, то оживить).
- Присваивание от const T& и T&&. Аналогично предыдущему (только копируемый объект априори жив).
- bool HasValue(). Возвращает жив объект, либо нет.
Явное приведение к bool. Аналогично предыдущему.
- Value(). Возвращает ссылку на объект. Если объект мертв, то бросается исключение BadOptionalAccess (которое тоже надо реализовать). Поддержать константную и неконстантную версии.
- Константный и неконстантный operator*. Аналогичен Value, но не осуществляет проверок.
- T& Emplace(args...). Принимает аргументы конструктора, с которыми нужно пересоздать объект (если он был жив, то вызвать деструктор и создать заново).
- void Reset(). Уничтожить объект, если тот был жив.